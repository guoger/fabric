// Code generated by counterfeiter. DO NOT EDIT.
package raftfakes

import (
	"sync"
	"time"

	etcdraft "github.com/coreos/etcd/raft"
	"github.com/hyperledger/fabric/orderer/consensus/raft"
	"github.com/hyperledger/fabric/protos/orderer"
)

type FakeRaftSupport struct {
	NewTickerStub        func() raft.Ticker
	newTickerMutex       sync.RWMutex
	newTickerArgsForCall []struct{}
	newTickerReturns     struct {
		result1 raft.Ticker
	}
	newTickerReturnsOnCall map[int]struct {
		result1 raft.Ticker
	}
	ChainIDStub        func() string
	chainIDMutex       sync.RWMutex
	chainIDArgsForCall []struct{}
	chainIDReturns     struct {
		result1 string
	}
	chainIDReturnsOnCall map[int]struct {
		result1 string
	}
	NodeIDStub        func() uint64
	nodeIDMutex       sync.RWMutex
	nodeIDArgsForCall []struct{}
	nodeIDReturns     struct {
		result1 uint64
	}
	nodeIDReturnsOnCall map[int]struct {
		result1 uint64
	}
	ElectionTickStub        func() int
	electionTickMutex       sync.RWMutex
	electionTickArgsForCall []struct{}
	electionTickReturns     struct {
		result1 int
	}
	electionTickReturnsOnCall map[int]struct {
		result1 int
	}
	HeartbeatTickStub        func() int
	heartbeatTickMutex       sync.RWMutex
	heartbeatTickArgsForCall []struct{}
	heartbeatTickReturns     struct {
		result1 int
	}
	heartbeatTickReturnsOnCall map[int]struct {
		result1 int
	}
	MaxSizePerMsgStub        func() uint64
	maxSizePerMsgMutex       sync.RWMutex
	maxSizePerMsgArgsForCall []struct{}
	maxSizePerMsgReturns     struct {
		result1 uint64
	}
	maxSizePerMsgReturnsOnCall map[int]struct {
		result1 uint64
	}
	MaxInflightMsgsStub        func() int
	maxInflightMsgsMutex       sync.RWMutex
	maxInflightMsgsArgsForCall []struct{}
	maxInflightMsgsReturns     struct {
		result1 int
	}
	maxInflightMsgsReturnsOnCall map[int]struct {
		result1 int
	}
	PeersStub        func() []etcdraft.Peer
	peersMutex       sync.RWMutex
	peersArgsForCall []struct{}
	peersReturns     struct {
		result1 []etcdraft.Peer
	}
	peersReturnsOnCall map[int]struct {
		result1 []etcdraft.Peer
	}
	TickIntervalStub        func() time.Duration
	tickIntervalMutex       sync.RWMutex
	tickIntervalArgsForCall []struct{}
	tickIntervalReturns     struct {
		result1 time.Duration
	}
	tickIntervalReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	StepStub        func(destination uint64, msg *orderer.StepRequest) (*orderer.StepResponse, error)
	stepMutex       sync.RWMutex
	stepArgsForCall []struct {
		destination uint64
		msg         *orderer.StepRequest
	}
	stepReturns struct {
		result1 *orderer.StepResponse
		result2 error
	}
	stepReturnsOnCall map[int]struct {
		result1 *orderer.StepResponse
		result2 error
	}
	SendSubmitRequestStub        func(destination uint64, request *orderer.SubmitRequest) error
	sendSubmitRequestMutex       sync.RWMutex
	sendSubmitRequestArgsForCall []struct {
		destination uint64
		request     *orderer.SubmitRequest
	}
	sendSubmitRequestReturns struct {
		result1 error
	}
	sendSubmitRequestReturnsOnCall map[int]struct {
		result1 error
	}
	ReceiveSubmitResponseStub        func(destination uint64) (*orderer.SubmitResponse, error)
	receiveSubmitResponseMutex       sync.RWMutex
	receiveSubmitResponseArgsForCall []struct {
		destination uint64
	}
	receiveSubmitResponseReturns struct {
		result1 *orderer.SubmitResponse
		result2 error
	}
	receiveSubmitResponseReturnsOnCall map[int]struct {
		result1 *orderer.SubmitResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRaftSupport) NewTicker() raft.Ticker {
	fake.newTickerMutex.Lock()
	ret, specificReturn := fake.newTickerReturnsOnCall[len(fake.newTickerArgsForCall)]
	fake.newTickerArgsForCall = append(fake.newTickerArgsForCall, struct{}{})
	fake.recordInvocation("NewTicker", []interface{}{})
	fake.newTickerMutex.Unlock()
	if fake.NewTickerStub != nil {
		return fake.NewTickerStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newTickerReturns.result1
}

func (fake *FakeRaftSupport) NewTickerCallCount() int {
	fake.newTickerMutex.RLock()
	defer fake.newTickerMutex.RUnlock()
	return len(fake.newTickerArgsForCall)
}

func (fake *FakeRaftSupport) NewTickerReturns(result1 raft.Ticker) {
	fake.NewTickerStub = nil
	fake.newTickerReturns = struct {
		result1 raft.Ticker
	}{result1}
}

func (fake *FakeRaftSupport) NewTickerReturnsOnCall(i int, result1 raft.Ticker) {
	fake.NewTickerStub = nil
	if fake.newTickerReturnsOnCall == nil {
		fake.newTickerReturnsOnCall = make(map[int]struct {
			result1 raft.Ticker
		})
	}
	fake.newTickerReturnsOnCall[i] = struct {
		result1 raft.Ticker
	}{result1}
}

func (fake *FakeRaftSupport) ChainID() string {
	fake.chainIDMutex.Lock()
	ret, specificReturn := fake.chainIDReturnsOnCall[len(fake.chainIDArgsForCall)]
	fake.chainIDArgsForCall = append(fake.chainIDArgsForCall, struct{}{})
	fake.recordInvocation("ChainID", []interface{}{})
	fake.chainIDMutex.Unlock()
	if fake.ChainIDStub != nil {
		return fake.ChainIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.chainIDReturns.result1
}

func (fake *FakeRaftSupport) ChainIDCallCount() int {
	fake.chainIDMutex.RLock()
	defer fake.chainIDMutex.RUnlock()
	return len(fake.chainIDArgsForCall)
}

func (fake *FakeRaftSupport) ChainIDReturns(result1 string) {
	fake.ChainIDStub = nil
	fake.chainIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeRaftSupport) ChainIDReturnsOnCall(i int, result1 string) {
	fake.ChainIDStub = nil
	if fake.chainIDReturnsOnCall == nil {
		fake.chainIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.chainIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeRaftSupport) NodeID() uint64 {
	fake.nodeIDMutex.Lock()
	ret, specificReturn := fake.nodeIDReturnsOnCall[len(fake.nodeIDArgsForCall)]
	fake.nodeIDArgsForCall = append(fake.nodeIDArgsForCall, struct{}{})
	fake.recordInvocation("NodeID", []interface{}{})
	fake.nodeIDMutex.Unlock()
	if fake.NodeIDStub != nil {
		return fake.NodeIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.nodeIDReturns.result1
}

func (fake *FakeRaftSupport) NodeIDCallCount() int {
	fake.nodeIDMutex.RLock()
	defer fake.nodeIDMutex.RUnlock()
	return len(fake.nodeIDArgsForCall)
}

func (fake *FakeRaftSupport) NodeIDReturns(result1 uint64) {
	fake.NodeIDStub = nil
	fake.nodeIDReturns = struct {
		result1 uint64
	}{result1}
}

func (fake *FakeRaftSupport) NodeIDReturnsOnCall(i int, result1 uint64) {
	fake.NodeIDStub = nil
	if fake.nodeIDReturnsOnCall == nil {
		fake.nodeIDReturnsOnCall = make(map[int]struct {
			result1 uint64
		})
	}
	fake.nodeIDReturnsOnCall[i] = struct {
		result1 uint64
	}{result1}
}

func (fake *FakeRaftSupport) ElectionTick() int {
	fake.electionTickMutex.Lock()
	ret, specificReturn := fake.electionTickReturnsOnCall[len(fake.electionTickArgsForCall)]
	fake.electionTickArgsForCall = append(fake.electionTickArgsForCall, struct{}{})
	fake.recordInvocation("ElectionTick", []interface{}{})
	fake.electionTickMutex.Unlock()
	if fake.ElectionTickStub != nil {
		return fake.ElectionTickStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.electionTickReturns.result1
}

func (fake *FakeRaftSupport) ElectionTickCallCount() int {
	fake.electionTickMutex.RLock()
	defer fake.electionTickMutex.RUnlock()
	return len(fake.electionTickArgsForCall)
}

func (fake *FakeRaftSupport) ElectionTickReturns(result1 int) {
	fake.ElectionTickStub = nil
	fake.electionTickReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeRaftSupport) ElectionTickReturnsOnCall(i int, result1 int) {
	fake.ElectionTickStub = nil
	if fake.electionTickReturnsOnCall == nil {
		fake.electionTickReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.electionTickReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeRaftSupport) HeartbeatTick() int {
	fake.heartbeatTickMutex.Lock()
	ret, specificReturn := fake.heartbeatTickReturnsOnCall[len(fake.heartbeatTickArgsForCall)]
	fake.heartbeatTickArgsForCall = append(fake.heartbeatTickArgsForCall, struct{}{})
	fake.recordInvocation("HeartbeatTick", []interface{}{})
	fake.heartbeatTickMutex.Unlock()
	if fake.HeartbeatTickStub != nil {
		return fake.HeartbeatTickStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.heartbeatTickReturns.result1
}

func (fake *FakeRaftSupport) HeartbeatTickCallCount() int {
	fake.heartbeatTickMutex.RLock()
	defer fake.heartbeatTickMutex.RUnlock()
	return len(fake.heartbeatTickArgsForCall)
}

func (fake *FakeRaftSupport) HeartbeatTickReturns(result1 int) {
	fake.HeartbeatTickStub = nil
	fake.heartbeatTickReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeRaftSupport) HeartbeatTickReturnsOnCall(i int, result1 int) {
	fake.HeartbeatTickStub = nil
	if fake.heartbeatTickReturnsOnCall == nil {
		fake.heartbeatTickReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.heartbeatTickReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeRaftSupport) MaxSizePerMsg() uint64 {
	fake.maxSizePerMsgMutex.Lock()
	ret, specificReturn := fake.maxSizePerMsgReturnsOnCall[len(fake.maxSizePerMsgArgsForCall)]
	fake.maxSizePerMsgArgsForCall = append(fake.maxSizePerMsgArgsForCall, struct{}{})
	fake.recordInvocation("MaxSizePerMsg", []interface{}{})
	fake.maxSizePerMsgMutex.Unlock()
	if fake.MaxSizePerMsgStub != nil {
		return fake.MaxSizePerMsgStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.maxSizePerMsgReturns.result1
}

func (fake *FakeRaftSupport) MaxSizePerMsgCallCount() int {
	fake.maxSizePerMsgMutex.RLock()
	defer fake.maxSizePerMsgMutex.RUnlock()
	return len(fake.maxSizePerMsgArgsForCall)
}

func (fake *FakeRaftSupport) MaxSizePerMsgReturns(result1 uint64) {
	fake.MaxSizePerMsgStub = nil
	fake.maxSizePerMsgReturns = struct {
		result1 uint64
	}{result1}
}

func (fake *FakeRaftSupport) MaxSizePerMsgReturnsOnCall(i int, result1 uint64) {
	fake.MaxSizePerMsgStub = nil
	if fake.maxSizePerMsgReturnsOnCall == nil {
		fake.maxSizePerMsgReturnsOnCall = make(map[int]struct {
			result1 uint64
		})
	}
	fake.maxSizePerMsgReturnsOnCall[i] = struct {
		result1 uint64
	}{result1}
}

func (fake *FakeRaftSupport) MaxInflightMsgs() int {
	fake.maxInflightMsgsMutex.Lock()
	ret, specificReturn := fake.maxInflightMsgsReturnsOnCall[len(fake.maxInflightMsgsArgsForCall)]
	fake.maxInflightMsgsArgsForCall = append(fake.maxInflightMsgsArgsForCall, struct{}{})
	fake.recordInvocation("MaxInflightMsgs", []interface{}{})
	fake.maxInflightMsgsMutex.Unlock()
	if fake.MaxInflightMsgsStub != nil {
		return fake.MaxInflightMsgsStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.maxInflightMsgsReturns.result1
}

func (fake *FakeRaftSupport) MaxInflightMsgsCallCount() int {
	fake.maxInflightMsgsMutex.RLock()
	defer fake.maxInflightMsgsMutex.RUnlock()
	return len(fake.maxInflightMsgsArgsForCall)
}

func (fake *FakeRaftSupport) MaxInflightMsgsReturns(result1 int) {
	fake.MaxInflightMsgsStub = nil
	fake.maxInflightMsgsReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeRaftSupport) MaxInflightMsgsReturnsOnCall(i int, result1 int) {
	fake.MaxInflightMsgsStub = nil
	if fake.maxInflightMsgsReturnsOnCall == nil {
		fake.maxInflightMsgsReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.maxInflightMsgsReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeRaftSupport) Peers() []etcdraft.Peer {
	fake.peersMutex.Lock()
	ret, specificReturn := fake.peersReturnsOnCall[len(fake.peersArgsForCall)]
	fake.peersArgsForCall = append(fake.peersArgsForCall, struct{}{})
	fake.recordInvocation("Peers", []interface{}{})
	fake.peersMutex.Unlock()
	if fake.PeersStub != nil {
		return fake.PeersStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.peersReturns.result1
}

func (fake *FakeRaftSupport) PeersCallCount() int {
	fake.peersMutex.RLock()
	defer fake.peersMutex.RUnlock()
	return len(fake.peersArgsForCall)
}

func (fake *FakeRaftSupport) PeersReturns(result1 []etcdraft.Peer) {
	fake.PeersStub = nil
	fake.peersReturns = struct {
		result1 []etcdraft.Peer
	}{result1}
}

func (fake *FakeRaftSupport) PeersReturnsOnCall(i int, result1 []etcdraft.Peer) {
	fake.PeersStub = nil
	if fake.peersReturnsOnCall == nil {
		fake.peersReturnsOnCall = make(map[int]struct {
			result1 []etcdraft.Peer
		})
	}
	fake.peersReturnsOnCall[i] = struct {
		result1 []etcdraft.Peer
	}{result1}
}

func (fake *FakeRaftSupport) TickInterval() time.Duration {
	fake.tickIntervalMutex.Lock()
	ret, specificReturn := fake.tickIntervalReturnsOnCall[len(fake.tickIntervalArgsForCall)]
	fake.tickIntervalArgsForCall = append(fake.tickIntervalArgsForCall, struct{}{})
	fake.recordInvocation("TickInterval", []interface{}{})
	fake.tickIntervalMutex.Unlock()
	if fake.TickIntervalStub != nil {
		return fake.TickIntervalStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.tickIntervalReturns.result1
}

func (fake *FakeRaftSupport) TickIntervalCallCount() int {
	fake.tickIntervalMutex.RLock()
	defer fake.tickIntervalMutex.RUnlock()
	return len(fake.tickIntervalArgsForCall)
}

func (fake *FakeRaftSupport) TickIntervalReturns(result1 time.Duration) {
	fake.TickIntervalStub = nil
	fake.tickIntervalReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeRaftSupport) TickIntervalReturnsOnCall(i int, result1 time.Duration) {
	fake.TickIntervalStub = nil
	if fake.tickIntervalReturnsOnCall == nil {
		fake.tickIntervalReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.tickIntervalReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeRaftSupport) Step(destination uint64, msg *orderer.StepRequest) (*orderer.StepResponse, error) {
	fake.stepMutex.Lock()
	ret, specificReturn := fake.stepReturnsOnCall[len(fake.stepArgsForCall)]
	fake.stepArgsForCall = append(fake.stepArgsForCall, struct {
		destination uint64
		msg         *orderer.StepRequest
	}{destination, msg})
	fake.recordInvocation("Step", []interface{}{destination, msg})
	fake.stepMutex.Unlock()
	if fake.StepStub != nil {
		return fake.StepStub(destination, msg)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.stepReturns.result1, fake.stepReturns.result2
}

func (fake *FakeRaftSupport) StepCallCount() int {
	fake.stepMutex.RLock()
	defer fake.stepMutex.RUnlock()
	return len(fake.stepArgsForCall)
}

func (fake *FakeRaftSupport) StepArgsForCall(i int) (uint64, *orderer.StepRequest) {
	fake.stepMutex.RLock()
	defer fake.stepMutex.RUnlock()
	return fake.stepArgsForCall[i].destination, fake.stepArgsForCall[i].msg
}

func (fake *FakeRaftSupport) StepReturns(result1 *orderer.StepResponse, result2 error) {
	fake.StepStub = nil
	fake.stepReturns = struct {
		result1 *orderer.StepResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeRaftSupport) StepReturnsOnCall(i int, result1 *orderer.StepResponse, result2 error) {
	fake.StepStub = nil
	if fake.stepReturnsOnCall == nil {
		fake.stepReturnsOnCall = make(map[int]struct {
			result1 *orderer.StepResponse
			result2 error
		})
	}
	fake.stepReturnsOnCall[i] = struct {
		result1 *orderer.StepResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeRaftSupport) SendSubmitRequest(destination uint64, request *orderer.SubmitRequest) error {
	fake.sendSubmitRequestMutex.Lock()
	ret, specificReturn := fake.sendSubmitRequestReturnsOnCall[len(fake.sendSubmitRequestArgsForCall)]
	fake.sendSubmitRequestArgsForCall = append(fake.sendSubmitRequestArgsForCall, struct {
		destination uint64
		request     *orderer.SubmitRequest
	}{destination, request})
	fake.recordInvocation("SendSubmitRequest", []interface{}{destination, request})
	fake.sendSubmitRequestMutex.Unlock()
	if fake.SendSubmitRequestStub != nil {
		return fake.SendSubmitRequestStub(destination, request)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.sendSubmitRequestReturns.result1
}

func (fake *FakeRaftSupport) SendSubmitRequestCallCount() int {
	fake.sendSubmitRequestMutex.RLock()
	defer fake.sendSubmitRequestMutex.RUnlock()
	return len(fake.sendSubmitRequestArgsForCall)
}

func (fake *FakeRaftSupport) SendSubmitRequestArgsForCall(i int) (uint64, *orderer.SubmitRequest) {
	fake.sendSubmitRequestMutex.RLock()
	defer fake.sendSubmitRequestMutex.RUnlock()
	return fake.sendSubmitRequestArgsForCall[i].destination, fake.sendSubmitRequestArgsForCall[i].request
}

func (fake *FakeRaftSupport) SendSubmitRequestReturns(result1 error) {
	fake.SendSubmitRequestStub = nil
	fake.sendSubmitRequestReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRaftSupport) SendSubmitRequestReturnsOnCall(i int, result1 error) {
	fake.SendSubmitRequestStub = nil
	if fake.sendSubmitRequestReturnsOnCall == nil {
		fake.sendSubmitRequestReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendSubmitRequestReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRaftSupport) ReceiveSubmitResponse(destination uint64) (*orderer.SubmitResponse, error) {
	fake.receiveSubmitResponseMutex.Lock()
	ret, specificReturn := fake.receiveSubmitResponseReturnsOnCall[len(fake.receiveSubmitResponseArgsForCall)]
	fake.receiveSubmitResponseArgsForCall = append(fake.receiveSubmitResponseArgsForCall, struct {
		destination uint64
	}{destination})
	fake.recordInvocation("ReceiveSubmitResponse", []interface{}{destination})
	fake.receiveSubmitResponseMutex.Unlock()
	if fake.ReceiveSubmitResponseStub != nil {
		return fake.ReceiveSubmitResponseStub(destination)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.receiveSubmitResponseReturns.result1, fake.receiveSubmitResponseReturns.result2
}

func (fake *FakeRaftSupport) ReceiveSubmitResponseCallCount() int {
	fake.receiveSubmitResponseMutex.RLock()
	defer fake.receiveSubmitResponseMutex.RUnlock()
	return len(fake.receiveSubmitResponseArgsForCall)
}

func (fake *FakeRaftSupport) ReceiveSubmitResponseArgsForCall(i int) uint64 {
	fake.receiveSubmitResponseMutex.RLock()
	defer fake.receiveSubmitResponseMutex.RUnlock()
	return fake.receiveSubmitResponseArgsForCall[i].destination
}

func (fake *FakeRaftSupport) ReceiveSubmitResponseReturns(result1 *orderer.SubmitResponse, result2 error) {
	fake.ReceiveSubmitResponseStub = nil
	fake.receiveSubmitResponseReturns = struct {
		result1 *orderer.SubmitResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeRaftSupport) ReceiveSubmitResponseReturnsOnCall(i int, result1 *orderer.SubmitResponse, result2 error) {
	fake.ReceiveSubmitResponseStub = nil
	if fake.receiveSubmitResponseReturnsOnCall == nil {
		fake.receiveSubmitResponseReturnsOnCall = make(map[int]struct {
			result1 *orderer.SubmitResponse
			result2 error
		})
	}
	fake.receiveSubmitResponseReturnsOnCall[i] = struct {
		result1 *orderer.SubmitResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeRaftSupport) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.newTickerMutex.RLock()
	defer fake.newTickerMutex.RUnlock()
	fake.chainIDMutex.RLock()
	defer fake.chainIDMutex.RUnlock()
	fake.nodeIDMutex.RLock()
	defer fake.nodeIDMutex.RUnlock()
	fake.electionTickMutex.RLock()
	defer fake.electionTickMutex.RUnlock()
	fake.heartbeatTickMutex.RLock()
	defer fake.heartbeatTickMutex.RUnlock()
	fake.maxSizePerMsgMutex.RLock()
	defer fake.maxSizePerMsgMutex.RUnlock()
	fake.maxInflightMsgsMutex.RLock()
	defer fake.maxInflightMsgsMutex.RUnlock()
	fake.peersMutex.RLock()
	defer fake.peersMutex.RUnlock()
	fake.tickIntervalMutex.RLock()
	defer fake.tickIntervalMutex.RUnlock()
	fake.stepMutex.RLock()
	defer fake.stepMutex.RUnlock()
	fake.sendSubmitRequestMutex.RLock()
	defer fake.sendSubmitRequestMutex.RUnlock()
	fake.receiveSubmitResponseMutex.RLock()
	defer fake.receiveSubmitResponseMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRaftSupport) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ raft.RaftSupport = new(FakeRaftSupport)
